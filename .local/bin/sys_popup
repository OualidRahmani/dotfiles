#!/usr/bin/env python3
import tkinter as tk
import psutil
import sys
import json
import os
import subprocess
import time

# Load colors
THEME_JSON = os.path.expanduser("~/.config/qtile_theme.json")
with open(THEME_JSON, "r") as f:
    colors = json.load(f)

mode = sys.argv[1] if len(sys.argv) > 1 else "cpu"

root = tk.Tk()
root.title("SysPopup")
root.overrideredirect(True)
root.attributes('-topmost', True)
root.configure(bg=colors['bg'], highlightbackground=colors['surface'], highlightthickness=2)

# Dynamic Sizing: CPU mode needs more vertical space for all cores
window_width = 530 if mode == "cpu" else 350
window_height = 410 if mode == "cpu" else (250 if mode == "ram" else 180)
BAR_HEIGHT = 30 
mouse_x = root.winfo_pointerx()
screen_width = 1920 
pos_x = min(max(10, mouse_x - (window_width // 2)), screen_width - window_width - 10)
root.geometry(f"{window_width}x{window_height}+{pos_x}+{BAR_HEIGHT}")

# --- Global trackers for real-time speed ---
last_net = psutil.net_io_counters()
last_time = time.time()

def get_cpu_governor(core_index):
    try:
        path = f"/sys/devices/system/cpu/cpu{core_index}/cpufreq/scaling_governor"
        with open(path, 'r') as f:
            return f.read().strip()
    except Exception:
        return "N/A"

def get_stats():
    if mode == "cpu":
        usages = psutil.cpu_percent(percpu=True)
        freqs = psutil.cpu_freq(percpu=True)
        output = ""
        for i, usage in enumerate(usages):
            gov = get_cpu_governor(i)
            gov_short = "PERF" if "performance" in gov else "SAVE"
            output += f"Core {i:02}: {usage: >4.1f}% | {freqs[i].current:4.0f}MHz | [{gov_short}]\n"
        output += f"\nTotal Load Avg: {psutil.getloadavg()}"
        return output

    elif mode == "ram":
        mem = psutil.virtual_memory()
        output = f"Used: {mem.used / (1024**3):.1f}GB / {mem.total / (1024**3):.1f}GB\n"
        output += f"Free: {mem.available / (1024**3):.1f}GB | Cached: {mem.cached / (1024**3):.1f}GB\n"
        output += "-" * 35 + "\n"
        output += "TOP 5 PROCESSES (BY RAM):\n"
        
        processes = []
        for proc in psutil.process_iter(['name', 'memory_info']):
            try:
                processes.append(proc.info)
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                pass
        
        top_5 = sorted(processes, key=lambda x: x['memory_info'].rss, reverse=True)[:5]
        for p in top_5:
            mb = p['memory_info'].rss / (1024**2)
            output += f"{p['name'][:15]:<15}: {mb:>8.1f} MB\n"
        return output

    elif mode == "gpu":
        try:
            res = subprocess.check_output(['nvidia-smi', '--query-gpu=temperature.gpu,memory.used,memory.total,power.draw', '--format=csv,noheader,nounits']).decode().strip().split(',')
            return f"Temp: {res[0]}Â°C\nVRAM: {res[1]}/{res[2]}MB\nPower: {res[3]}W"
        except: return "GPU Idle"

    return "Loading Data..."

def update_display():
    global last_net, last_time
    
    if mode == "net":
        current_time = time.time()
        elapsed = current_time - last_time
        now_net = psutil.net_io_counters()
        
        # Prevent division by zero on the first tick
        if elapsed > 0:
            up_speed = (now_net.bytes_sent - last_net.bytes_sent) / (1024 * elapsed)
            down_speed = (now_net.bytes_recv - last_net.bytes_recv) / (1024 * elapsed)
            
            output = f"Download: {down_speed: >8.1f} KB/s\n"
            output += f"Upload:   {up_speed: >8.1f} KB/s\n"
            output += "-" * 35 + "\n"
            output += f"Total Sent: {now_net.bytes_sent / (1024**2):.1f} MB\n"
            output += f"Total Recv: {now_net.bytes_recv / (1024**2):.1f} MB"
            
            last_net = now_net
            last_time = current_time
            info_text.config(text=output)
            
    else:
        # For CPU, RAM, and GPU, just fetch the fresh stats and update the UI
        info_text.config(text=get_stats())

    # Dynamic refresh rate: CPU and Net update fast (500ms), RAM updates slower (1000ms) to save resources
    refresh_rate = 1000 if mode == "ram" else 500
    root.after(refresh_rate, update_display)

# UI Setup
header = tk.Label(root, text=f"--- {mode.upper()} MONITOR ---", fg=colors['mauve'], bg=colors['bg'], font=("JetBrains Mono", 14, "bold"))
header.pack(pady=10)

# We use a text widget for CPU so it doesn't cut off
info_frame = tk.Frame(root, bg=colors['bg'])
info_frame.pack(fill="both", expand=True, padx=20)

info_text = tk.Label(info_frame, text="Calculating...", fg=colors['fg'], bg=colors['bg'], font=("JetBrains Mono", 10), justify="left")
info_text.pack()

# Auto-close hooks
root.bind("<Button-1>", lambda e: root.destroy())
root.bind("<FocusOut>", lambda e: root.destroy())
root.after(15000, root.destroy) # 15s timeout

# Kick off the loop
update_display()
root.mainloop()